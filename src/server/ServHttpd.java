/**
 * Sistemas de Telecomunicacoes 
 *          2018/2019
 *
 * ServHttpd.java
 *
 * Main class with graphical interface and server control logic
 *
 * Created on February 20, 2019, 10:00
 *
 * @author Luis Bernardo
 */

package server;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.IOException;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.ServerSocket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.HashMap;
import javax.swing.JFileChooser;
import javax.swing.JTextField;

public class ServHttpd extends javax.swing.JFrame {
    /**
     * Number of the members of the group
     */
    public final static int[] STUDENT_NUMBERS= { 0, 0, 0 };
    /**
     * Server name
     */
    public final static String SERVER_NAME = "HTTP Serv "+STUDENT_NUMBERS[0]+
            "/"+STUDENT_NUMBERS[1]+"/"+STUDENT_NUMBERS[2];   
    /**
     * Maximum packet size for AUTH_REQ and AUTH_REP
     */
    public final static int MAX_PACKET_LENGTH = 120;
    /**
     * Default file name when browser sends "/"
     */
    public final static String HOMEFILENAME = "index.htm";
    /**
     * Accepts up to 10 pending TCP connections
     */
    public final static int MAX_ACCEPT_LOG = 10;
    /**
     * Maximum timeout waiting for answer from Authentication server [ms]
     */
    public final static int AUTH_TIMEOUT = 1000;
    /**
     * Maximum time a password can be stored in cache [ms]
     */
    public final static int MAX_PASSW_STORE_TIME = 60000;
    /**
     * Server socket where new connections are accepted
     */
    public ServerSocket ssock;
    /**
     * Main thread that accepts new connections
     */
    Daemon_tcp main_thread = null;
    /**
     * Datagram socket used to send REGIST messages to the proxy
     */
    public DatagramSocket ds;
    /**
     * Number of the first member of group
     */
    public final int number1= 0;
    /**
     * Number of the  second member of group
     */
    public final int number2= 0;
    /**
     * Number of the third member of group
     */
    public final int number3= 0;
    /**
     * Sequence number for AUTH_REQ messages
     */
    private static int AUTH_Req_seq= 0;
    /**
     * HashMap with list of stored challenges (i.e. cache)
     */
    private final HashMap<String,ChallengeResponse> cache= new HashMap<>(); 
    
    
    /**
     * Constructor
     * @param type  type format to be used
     */
    public ServHttpd(byte type) {
        initComponents();
        super.setTitle(SERVER_NAME);
        ds = null;
        ssock = null;
        if ((type > 0) && (type<5)) {
            this.jTextType.setText(Byte.toString(type));
        }
        System.out.println("type= "+type);
        // this.jTextHtmlRoot.setText("/home/guest/Desktop/html"); // Put here your html directory path 
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFileChooser1 = new javax.swing.JFileChooser();
        jPanel1 = new javax.swing.JPanel();
        jToggleButton1 = new javax.swing.JToggleButton();
        jLabel5 = new javax.swing.JLabel();
        jTextLocalIP = new javax.swing.JTextField();
        jLabel4 = new javax.swing.JLabel();
        jTextLocalPort = new javax.swing.JTextField();
        jPanel3 = new javax.swing.JPanel();
        jLabelHtml = new javax.swing.JLabel();
        jTextHtmlRoot = new javax.swing.JTextField();
        jPanel4 = new javax.swing.JPanel();
        jLabel9 = new javax.swing.JLabel();
        jTextUser = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        jTextLifetime = new javax.swing.JTextField();
        jButtonTest = new javax.swing.JButton();
        jButtonClear = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jLabel7 = new javax.swing.JLabel();
        jTextType = new javax.swing.JTextField();
        jLabel3 = new javax.swing.JLabel();
        jTextAuthIP = new javax.swing.JTextField();
        jLabel6 = new javax.swing.JLabel();
        jTextAuthPort = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();

        setTitle("Defined in constructor");
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                exitForm(evt);
            }
        });
        getContentPane().setLayout(new javax.swing.BoxLayout(getContentPane(), javax.swing.BoxLayout.Y_AXIS));

        jPanel1.setMaximumSize(new java.awt.Dimension(450, 35));
        jPanel1.setMinimumSize(new java.awt.Dimension(450, 35));
        jPanel1.setName("Estado"); // NOI18N
        jPanel1.setPreferredSize(new java.awt.Dimension(450, 35));

        jToggleButton1.setText("Active");
        jToggleButton1.setMaximumSize(new java.awt.Dimension(85, 29));
        jToggleButton1.setPreferredSize(new java.awt.Dimension(85, 29));
        jToggleButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jToggleButton1ActionPerformed(evt);
            }
        });
        jPanel1.add(jToggleButton1);

        jLabel5.setText("IP");
        jPanel1.add(jLabel5);

        jTextLocalIP.setEditable(false);
        jTextLocalIP.setPreferredSize(new java.awt.Dimension(200, 20));
        jPanel1.add(jTextLocalIP);

        jLabel4.setHorizontalAlignment(javax.swing.SwingConstants.TRAILING);
        jLabel4.setText("Port");
        jLabel4.setMaximumSize(new java.awt.Dimension(35, 17));
        jLabel4.setPreferredSize(new java.awt.Dimension(35, 17));
        jPanel1.add(jLabel4);

        jTextLocalPort.setText("20000");
        jPanel1.add(jTextLocalPort);

        getContentPane().add(jPanel1);

        jPanel3.setMaximumSize(new java.awt.Dimension(390, 37));
        jPanel3.setMinimumSize(new java.awt.Dimension(60, 33));
        jPanel3.setPreferredSize(new java.awt.Dimension(480, 33));

        jLabelHtml.setText("Html:");
        jLabelHtml.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jLabelHtmlMouseClicked(evt);
            }
        });
        jPanel3.add(jLabelHtml);

        jTextHtmlRoot.setText("Click 'Html:' to select HTML directory");
        jTextHtmlRoot.setPreferredSize(new java.awt.Dimension(330, 24));
        jTextHtmlRoot.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusLost(java.awt.event.FocusEvent evt) {
                jTextHtmlRootFocusLost(evt);
            }
        });
        jTextHtmlRoot.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextHtmlRootActionPerformed(evt);
            }
        });
        jPanel3.add(jTextHtmlRoot);

        getContentPane().add(jPanel3);

        jPanel4.setMaximumSize(new java.awt.Dimension(32767, 39));

        jLabel9.setText("User:");
        jPanel4.add(jLabel9);

        jTextUser.setText("user");
        jTextUser.setPreferredSize(new java.awt.Dimension(50, 26));
        jPanel4.add(jTextUser);

        jLabel2.setText("Lifetime:");
        jPanel4.add(jLabel2);

        jTextLifetime.setText("60000");
        jTextLifetime.setPreferredSize(new java.awt.Dimension(70, 26));
        jPanel4.add(jTextLifetime);

        jButtonTest.setBackground(new java.awt.Color(102, 255, 255));
        jButtonTest.setText("Test server");
        jButtonTest.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonTestActionPerformed(evt);
            }
        });
        jPanel4.add(jButtonTest);

        jButtonClear.setBackground(new java.awt.Color(255, 255, 0));
        jButtonClear.setText("Clear");
        jButtonClear.setMaximumSize(new java.awt.Dimension(75, 29));
        jButtonClear.setPreferredSize(new java.awt.Dimension(75, 29));
        jButtonClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonClearActionPerformed(evt);
            }
        });
        jPanel4.add(jButtonClear);

        getContentPane().add(jPanel4);

        jPanel2.setToolTipText("configuração");
        jPanel2.setMaximumSize(new java.awt.Dimension(440, 35));
        jPanel2.setMinimumSize(new java.awt.Dimension(420, 35));
        jPanel2.setName("configuracao"); // NOI18N
        jPanel2.setPreferredSize(new java.awt.Dimension(440, 35));

        jLabel1.setText("  Cnt Server:");
        jPanel2.add(jLabel1);

        jLabel7.setText("Type");
        jPanel2.add(jLabel7);

        jTextType.setText("1");
        jTextType.setPreferredSize(new java.awt.Dimension(19, 19));
        jPanel2.add(jTextType);

        jLabel3.setText("  IP ");
        jPanel2.add(jLabel3);

        jTextAuthIP.setText("127.0.0.1");
        jTextAuthIP.setMinimumSize(new java.awt.Dimension(14, 27));
        jTextAuthIP.setPreferredSize(new java.awt.Dimension(130, 24));
        jPanel2.add(jTextAuthIP);

        jLabel6.setText("Port ");
        jPanel2.add(jLabel6);

        jTextAuthPort.setText("20001");
        jTextAuthPort.setPreferredSize(new java.awt.Dimension(60, 24));
        jPanel2.add(jTextAuthPort);

        getContentPane().add(jPanel2);

        jScrollPane1.setPreferredSize(new java.awt.Dimension(360, 180));

        jTextArea1.setLineWrap(true);
        jTextArea1.setPreferredSize(new java.awt.Dimension(200, 2000));
        jTextArea1.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                jTextArea1KeyPressed(evt);
            }
        });
        jScrollPane1.setViewportView(jTextArea1);

        getContentPane().add(jScrollPane1);

        getAccessibleContext().setAccessibleName("HTTP GUI - RIT2 2011/2012 by ?????/?????/?????");

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Validates the html root directory name where the files are read
     * @param f
     */
    public void validate_name(javax.swing.JTextField f) {
        String str = f.getText();
        if (str.length() == 0) {
            return;
        }
        str= str.trim();
        if (str.charAt(str.length() - 1) != File.separatorChar) {
            str = str + File.separatorChar;
        } else {
            while ((str.length() > 1) && (str.charAt(str.length() - 2) == File.separatorChar)) {
                str = str.substring(0, str.length() - 1);
            }
        }
        f.setText(str);
    }

    
    /**
     * Automatically validates the html directory name
     */
    private void jTextHtmlRootFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jTextHtmlRootFocusLost
        validate_name(jTextHtmlRoot);
    }//GEN-LAST:event_jTextHtmlRootFocusLost

    /**
     * Clear the text area
     */
    private void jButtonClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearActionPerformed
        jTextArea1.setText("");
    }//GEN-LAST:event_jButtonClearActionPerformed

    /**
     * Clear the text area
     */
    private void jTextArea1KeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTextArea1KeyPressed
        if (evt.getKeyChar() == ' ') {
            jTextArea1.setText("");
        }
    }//GEN-LAST:event_jTextArea1KeyPressed

    /**
     * Handles the button that starts and stops the Server 
     */
    private void jToggleButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jToggleButton1ActionPerformed
        if (jToggleButton1.isSelected()) {
            // Parse GUI parameters            
            int tcp_port;
            try {
                tcp_port = Integer.parseInt(jTextLocalPort.getText());
            } catch (NumberFormatException e) {
                Log("Invalid port number\n");
                jToggleButton1.setSelected(false);
                return;
            }
            // Starts the server socket
            int cnt = 0;
            do {
                try {
                    ssock = new ServerSocket(tcp_port+cnt, MAX_ACCEPT_LOG);
                } catch (java.io.IOException e) {
                    // If the tcp_port is already used, try the next one until reaching a free one
                    if (cnt>100) {
                        Log("Web server start failure: " + e + "\n");
                        jToggleButton1.setSelected(false);
                        return;
                    }
                    cnt++;
                }
            } while (ssock == null);
            jTextLocalPort.setText(Long.toString(tcp_port+cnt)); // Writes the port used.
            
            // Gets the local IP
            try {
                jTextLocalIP.setText(InetAddress.getLocalHost().getHostAddress());
            } catch (UnknownHostException e) {
                Log("Failed to get local IP: " + e + "\n");
            }
            
            // Start the UDP socket
            try {
                ds = new DatagramSocket(0);     // 0 means, use a random free port
                ds.setSoTimeout(AUTH_TIMEOUT);  // Define a maximum waiting time in receive operations
            } catch (SocketException ex) {
                Log("Failed creation of UDP socket: " + ex + "\n");
                try {
                    ssock.close();
                } catch (IOException ex1) {
                    Log("Error closing TCP socket: " + ex1 + "\n");
                    ssock = null;
                }
                jToggleButton1.setSelected(false);
                return;
            }

            // starts the main thread (that receives connections)
            main_thread = new Daemon_tcp(this, ssock);
            main_thread.start();                       
            
            setEditable_jText(false);
            Log("Web server active\n");
        } else {
            // Stop the server socket thread and the sockets
            try {
                if (ds != null) {
                    ds.close();
                    ds = null;
                }               
                if (main_thread != null) {
                    main_thread.stop_thread();
                    main_thread = null;
                }
                if (ssock != null) {
                    ssock.close();
                    ssock = null;
                }
            } catch (IOException e) {
                Log("Exception closing server: " + e + "\n");
            }
            setEditable_jText(true);
            Log("Web server stopped\n");
        }
    }//GEN-LAST:event_jToggleButton1ActionPerformed

    /**
     * Exit the Application
     */
    private void exitForm(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_exitForm
        System.exit(0);
    }//GEN-LAST:event_exitForm

    /**
     * Test the communication with the Authentication server
     * @param evt 
     */
    private void jButtonTestActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonTestActionPerformed
        if (!jToggleButton1.isSelected()) {
            Log("Server is not active\n");
            return;
        }
        try {
            ChallengeResponse re= get_challengeresponse(this.jTextUser.getText());
            Log("Returned challenge_response= " + (re==null?"null":re.toString()) + "\n");
        }
        catch(Exception e) {
            Log("Error testing CountServer: "+e+"\n");
        }
        
    }//GEN-LAST:event_jButtonTestActionPerformed

    /**
     * Open a directory selection window to select the HTML root
     */
    private void select_html_directory() {
        try {
            // Choose file to write the list
            this.jFileChooser1.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
            if (jFileChooser1.showDialog(this, "Select directory with html files") == JFileChooser.APPROVE_OPTION) {
                File f = jFileChooser1.getSelectedFile();
                this.jTextHtmlRoot.setText(f.getAbsolutePath());
            }
        } catch (Exception e) {
            System.err.println("Error selecting html directory:" + e);
        }        
    }
    
    private void jLabelHtmlMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jLabelHtmlMouseClicked
        select_html_directory();
    }//GEN-LAST:event_jLabelHtmlMouseClicked

    private void jTextHtmlRootActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextHtmlRootActionPerformed
        select_html_directory();
    }//GEN-LAST:event_jTextHtmlRootActionPerformed

    /**
     * Count server's IP address
     * @return IP address
     */
    public InetAddress get_AuthServer_IP() {
        String str= jTextAuthIP.getText();
        try {
            return InetAddress.getByName(str);
        } catch (UnknownHostException e) {
            Log("Invalid AuthServer IP address '"+str+"': "+e+"\n");
            return null;
        }
    }
    
    /**
     * Count server's port number
     * @return port number
     */
    public int get_AuthServer_Port() {
        String str= this.jTextAuthPort.getText();
        try {
            return Integer.parseInt(str);
        } catch (NumberFormatException e) {
            Log("Invalid AuthServer port number '"+str+"': "+e+"\n");
            return 0;
        }
    }

   /**
     * Count server's port number
     * @return port number
     */
    public int get_Lifetime_value() {
        String str= this.jTextLifetime.getText();
        try {
            return Integer.parseInt(str);
        } catch (NumberFormatException e) {
            Log("Invalid Lifetime value '"+str+"': "+e+"\n");
            return MAX_PASSW_STORE_TIME;
        }
    }
    
    /**
     * Send a AUTH_REQ message to the Authentication server
     * @param servIP    Authentication server's IP address
     * @param servPort  Authentication server's port number
     * @param user      Requested user authentication information
     * @param seq       Unique sequence number
     * @return          true is AUTH_REQ was sent successfuly
     */
    boolean send_AUTH_REQ(byte type, InetAddress servIP, int servPort, String user, int seq) {
        
        // Validate contents
        if ((servIP == null) || (servPort <= 0) || (user == null)) {
            Log("Invalid parameter in send_AUTH_REQ");
            return false;
        }
        // Create and send packet
        ByteArrayOutputStream os = new ByteArrayOutputStream(); // Prepares a message 
        DataOutputStream dos = new DataOutputStream(os);        //   writting object
        try {
            dos.writeByte(type);
            dos.writeInt(seq);
            dos.writeInt(STUDENT_NUMBERS[0]);
            dos.writeInt(STUDENT_NUMBERS[1]);
            dos.writeInt(STUDENT_NUMBERS[2]);
            dos.writeShort(user.length());
            dos.writeBytes(user);
            // Prepare message
            byte[] buffer = os.toByteArray();       // Convert to byte array   
            DatagramPacket dp = new DatagramPacket(buffer, buffer.length, servIP, servPort); // Create packet
            ds.send(dp);

            Log("Sent AUTH_REQ ("+seq+";"+user+";"+STUDENT_NUMBERS[0]+"-"+
                    STUDENT_NUMBERS[1]+"-"+STUDENT_NUMBERS[2]+") to "+servIP+":"+servPort+"\n");
            return true;
        } catch (Exception e) {
            // Catches all exceptions
            Log("Error preparing or sending AUTH_REQ message: "+e+"\n");
            return false;
        }
    }

    /**
     * Controls editability of jTexts
     *
     * @param editable
     */
    public void setEditable_jText(boolean editable) {
        jTextLocalPort.setEditable(editable);
        jTextHtmlRoot.setEditable(editable);
    }

    /**
     * Logs a message on the command line and on the text area
     *
     * @param s string to be written
     */
    public void Log(String s) {
        jTextArea1.append(s);
        System.out.print(s);
    }

    /**
     * Returns the port number in a JTextField
     */
    private int getPort(JTextField jt) {
        try {
            int port = Integer.parseInt(jt.getText());
            if ((port <= 0) || (port > 65535)) {
                return 0;
            }
            return port;
        } catch (NumberFormatException e) {
            return 0;
        }
    }

    /**
     * Returns the local TCP port number
     *
     * @return local port number
     */
    public int getLocalPort() {
        return getPort(jTextLocalPort);
    }

    /**
     * Returns the Proxy's UDP port number
     *
     * @return proxy port number
     */
    public int getProxyPort() {
        return getPort(jTextAuthPort);
    }

    /**
     * Returns the root html directory
     *
     * @return string with the root pathname
     */
    public String getRaizHtml() {
        return jTextHtmlRoot.getText();
    }
    
    /**
     * Increments the AUTH_REQ sequence number and returns it
     * 
     * @return sequence number
     */
    public int get_NextSEQ() {
        return ++AUTH_Req_seq;
    }


    public boolean valid_KEY(String key) {
        if (key == null) {
            Log("ERROR: valid_KEY called with null key\n");
            return false;
        }
        int userb= key.indexOf("user="), userf= key.indexOf('&');
        String user= key.substring(userb+5, userf);
        Log("valid_KEY("+user+")\n");
        ChallengeResponse re= cache.get(user);
        if ((re != null) && re.is_valid()) {
            return re.validate_client_string(key);
        } else {
            Log("user "+user+" is not in the list\n");
            return false;
        }
    }

    
    /**
     * Auxiliary function to read a String from a DataInputStream
     * @param dis   DataInputStream associated to a socket or a file
     * @return  String received
     * @throws IOException 
     */
    public static String read_String(DataInputStream dis) throws IOException {
        short len=  dis.readShort();
        if (len > 0) {
            byte[] buf= new byte[len];
            dis.read(buf);
            return new String(buf);
        } else
            return "";
    }

    
    /**
     * Function that sends AUTH_REQ and receives AUTH_REP messages
     * @param user  user id
     * @return Challenge Response object with authentication data, or new
     */
    public ChallengeResponse get_new_challengeresponse(String user) {
        if (user == null) {
            Log("null user in get_challengeresponse\n");
            return null;
        }

        byte[] buf=new byte[ServHttpd.MAX_PACKET_LENGTH];
        DatagramPacket rdp= new DatagramPacket(buf,buf.length);
        // Parameters in AUTH_REQ
        byte type;
        int seq;
        // Parameters received in AUTH_REP
        byte rtype=-1;
        int rnumber1=-1, rnumber2=-1, rnumber3=-1;
        int rseq=-1;
        int[] challenge= new int[3];
        String ruser="", response= "";
        
        seq= get_NextSEQ(); // Get next sequence number
        try {
            type= Byte.parseByte(this.jTextType.getText());
        } catch (NumberFormatException e) {
            Log("Invalid Type value '"+this.jTextType.getText()+"': "+e+"\n");
            return null;
        }

        try {
            send_AUTH_REQ(type, get_AuthServer_IP(), get_AuthServer_Port(), 
                          user, seq);

            ds.receive(rdp);
            ByteArrayInputStream BAis =
                    new ByteArrayInputStream(buf, 0, rdp.getLength());
            DataInputStream dis = new DataInputStream(BAis);
            
            // Parse Auth_Rep message
            Log("Function ServHttpd.get_new_challengeresponse is incomplete.\n");
            
            /********************************
             * Lab work 3 - TASK 3: 
             *      a) Read all the fields of AUTH_REP according to your type number
             *          using the dis object to the local variables declared above
             *      b) Test the values received that were sent (user, seq)
             *      c) Create a new ChallengeResponse object with the data 
             *          received (including an empty response (length 0)
             *      d) Store in cache (i.e. in list cache) if a challenge/response was received
             */
            
            // Implement a) here

            if (dis.available() > 0) {  // More bytes after the message in the buffer
                Log("Packet too long\n");
                return null;
            }
            
            if (response.length() > 0)
                Log("Received AUTH_REP (C:"+challenge[0]+challenge[1]+challenge[2]+"-R:"+
                    response+";"+rnumber1+"-"+rnumber2+"-"+rnumber3+") from "+
                    rdp.getAddress().getHostAddress()+":"+rdp.getPort()+"\n");
            else
                Log("Received AUTH_REP (no user;"+rnumber1+"-"+rnumber2+"-"+rnumber3+") from "+
                    rdp.getAddress().getHostAddress()+":"+rdp.getPort()+"\n");
            
            // Implement b) - Validate rseq and ruser
                        
            // Implement c) create ChallengeResponse object
            ChallengeResponse re= null; // new ChallengeResponse(...);
            
            // Implement d): Add user to the hashmap list (cache) only if the user exists
            
            return re;
        } catch (SocketTimeoutException ex) {
            // No answer from authentication server
            Log("Timeout waiting for AUTH_REP\n");
            return null;
            
        } catch (IOException ex) {
            // Error in reading from buffer - packet too short
            Log("Error in communication with authentication server:\n "+ex+"\n");
            return null;
            
        } catch (Exception ex) {
            // Error in communication
            Log("Exception in function get_challengeresponse:\n "+ex+"\n");
            return null;
        }  
    }


    /**
     * Function that looks for authentication data in the cache cache
     * @param user  user id
     * @return Challenge Response object with authentication data
     */
    public ChallengeResponse get_cached_challengeresponse(String user) {
        if (user == null) {
            Log("null user in get_challengeresponse\n");
            return null;
        }
        /********************************
         * Lab work 3 - TASK 4: 
         *      Program here the algorithm to test if the challenge-response is stored in the cache,
         *          and if it still is valid, return it.
         *      Otherwise, return null;
         */
        // ...

        return null;
    }

    
    /**
     * Function that gets a challenge_response pair. First uses cache and gets new
     *     if none is available
     * @param user  user id
     * @return Challenge Response object with authentication data, or null
     */
    public ChallengeResponse get_challengeresponse(String user) {
        if (user == null) {
            Log("null user in get_challengeresponse\n");
            return null;
        }
        ChallengeResponse re= get_cached_challengeresponse(user);
        if (re == null)
            re= get_new_challengeresponse(user);
        
        return re;
    }

    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        byte type= 1;
        if (args.length > 0) {
            try {
                type= Byte.parseByte(args[0]);
            } catch (NumberFormatException e) {
                type= 1;
            }
        }
        new ServHttpd(type).setVisible(true);
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonClear;
    private javax.swing.JButton jButtonTest;
    private javax.swing.JFileChooser jFileChooser1;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JLabel jLabelHtml;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextField jTextAuthIP;
    private javax.swing.JTextField jTextAuthPort;
    private javax.swing.JTextField jTextHtmlRoot;
    private javax.swing.JTextField jTextLifetime;
    private javax.swing.JTextField jTextLocalIP;
    private javax.swing.JTextField jTextLocalPort;
    private javax.swing.JTextField jTextType;
    private javax.swing.JTextField jTextUser;
    private javax.swing.JToggleButton jToggleButton1;
    // End of variables declaration//GEN-END:variables
}
